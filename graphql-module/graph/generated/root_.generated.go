// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Address() AddressResolver
	City() CityResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Actor struct {
		ActorID    func(childComplexity int) int
		FirstName  func(childComplexity int) int
		LastName   func(childComplexity int) int
		LastUpdate func(childComplexity int) int
	}

	Address struct {
		Address    func(childComplexity int) int
		Address2   func(childComplexity int) int
		AddressID  func(childComplexity int) int
		CityID     func(childComplexity int) int
		District   func(childComplexity int) int
		LastUpdate func(childComplexity int) int
		Phone      func(childComplexity int) int
		PostalCode func(childComplexity int) int
	}

	City struct {
		City       func(childComplexity int) int
		CityID     func(childComplexity int) int
		CountryID  func(childComplexity int) int
		LastUpdate func(childComplexity int) int
	}

	Mutation struct {
		Empty func(childComplexity int) int
	}

	Query struct {
		Actors    func(childComplexity int) int
		Address   func(childComplexity int, addressID string) int
		Addresses func(childComplexity int) int
		City      func(childComplexity int, cityID string) int
		Empty     func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Actor.actor_id":
		if e.complexity.Actor.ActorID == nil {
			break
		}

		return e.complexity.Actor.ActorID(childComplexity), true

	case "Actor.first_name":
		if e.complexity.Actor.FirstName == nil {
			break
		}

		return e.complexity.Actor.FirstName(childComplexity), true

	case "Actor.last_name":
		if e.complexity.Actor.LastName == nil {
			break
		}

		return e.complexity.Actor.LastName(childComplexity), true

	case "Actor.last_update":
		if e.complexity.Actor.LastUpdate == nil {
			break
		}

		return e.complexity.Actor.LastUpdate(childComplexity), true

	case "Address.address":
		if e.complexity.Address.Address == nil {
			break
		}

		return e.complexity.Address.Address(childComplexity), true

	case "Address.address2":
		if e.complexity.Address.Address2 == nil {
			break
		}

		return e.complexity.Address.Address2(childComplexity), true

	case "Address.address_id":
		if e.complexity.Address.AddressID == nil {
			break
		}

		return e.complexity.Address.AddressID(childComplexity), true

	case "Address.city_id":
		if e.complexity.Address.CityID == nil {
			break
		}

		return e.complexity.Address.CityID(childComplexity), true

	case "Address.district":
		if e.complexity.Address.District == nil {
			break
		}

		return e.complexity.Address.District(childComplexity), true

	case "Address.last_update":
		if e.complexity.Address.LastUpdate == nil {
			break
		}

		return e.complexity.Address.LastUpdate(childComplexity), true

	case "Address.phone":
		if e.complexity.Address.Phone == nil {
			break
		}

		return e.complexity.Address.Phone(childComplexity), true

	case "Address.postal_code":
		if e.complexity.Address.PostalCode == nil {
			break
		}

		return e.complexity.Address.PostalCode(childComplexity), true

	case "City.city":
		if e.complexity.City.City == nil {
			break
		}

		return e.complexity.City.City(childComplexity), true

	case "City.city_id":
		if e.complexity.City.CityID == nil {
			break
		}

		return e.complexity.City.CityID(childComplexity), true

	case "City.country_id":
		if e.complexity.City.CountryID == nil {
			break
		}

		return e.complexity.City.CountryID(childComplexity), true

	case "City.last_update":
		if e.complexity.City.LastUpdate == nil {
			break
		}

		return e.complexity.City.LastUpdate(childComplexity), true

	case "Mutation._empty":
		if e.complexity.Mutation.Empty == nil {
			break
		}

		return e.complexity.Mutation.Empty(childComplexity), true

	case "Query.actors":
		if e.complexity.Query.Actors == nil {
			break
		}

		return e.complexity.Query.Actors(childComplexity), true

	case "Query.address":
		if e.complexity.Query.Address == nil {
			break
		}

		args, err := ec.field_Query_address_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Address(childComplexity, args["address_id"].(string)), true

	case "Query.addresses":
		if e.complexity.Query.Addresses == nil {
			break
		}

		return e.complexity.Query.Addresses(childComplexity), true

	case "Query.city":
		if e.complexity.Query.City == nil {
			break
		}

		args, err := ec.field_Query_city_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.City(childComplexity, args["city_id"].(string)), true

	case "Query._empty":
		if e.complexity.Query.Empty == nil {
			break
		}

		return e.complexity.Query.Empty(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap()
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../actor.graphqls", Input: `extend type Query {
    actors: [Actor!]!
}

type Actor {
    actor_id: ID!
    first_name: String
    last_name: String
    last_update: Time
}`, BuiltIn: false},
	{Name: "../address.graphqls", Input: `extend type Query {
    address(address_id: ID!): Address
    addresses: [Address!]!
}

type Address {
    address_id: ID!
    address: String
    address2: String
    district: String
    city_id: ID
    postal_code: String
    phone: String
    last_update: Time
}`, BuiltIn: false},
	{Name: "../city.graphqls", Input: `extend type Query {
    city(city_id: ID!): City
}

type City {
    city_id: ID!
    city: String
    country_id: ID
    last_update: Time
}`, BuiltIn: false},
	{Name: "../schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Query {
  _empty: String
}

type Mutation {
  _empty: String
}

scalar Time`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
